#! /bin/zsh

# ttypist — the simplest possible terminal-based typing tutor/speed test

# TODO
# make high score dependent also on poolband, dict
# premature end with calcs on return
# process input args
# word sets available by name (english200 etc)
# distribute dict file, man page
# deal with apostrophes in word list
# if "installation" is missed, re-present "installer" "installed" "installable" etc
# fix word list to not have words like according_to
# color each word green if typed correctly (or red)
# track slow words (timer for each word)
# audible "ding" at N seconds
# "difficulty" level: a freq band; level=5 -> rank 40k-50k (TTYP_POOLMIN=40000 TTYP_POOLSIZE=10000)
# repeat last test
# word-length range: only words between 8-20 chars
# letter build-up: rr rrn rnr nnr, rtn trn rrt ntr, rst srt trns stnr rnts, rats tart rsa ratn raat # < /dev/urandom tr -dc stnr | head -c "$((RANDOM % 8 + 1))"

# dict=${TTYP_DICT-~/contrib/dict/10k-3.num}
dict=${TTYP_DICT-${0:h}/../10k-3.num}
nwords=${TTYP_NWORDS-50}

# Set "band" range of words; allow for a single upper bound with 0 as default
# if   [[ -n $TTYP_POOLBAND ]] && grep -E -v '[1-9][0-9]*-[1-9][0-9]*' <<< $TTYP_POOLBAND
# then print "TTYP_POOLBAND must be an integer or range like 1-300"; exit 1
# fi
bands=${TTYP_POOLBAND-1-200}; bands=( ${(s:-:)bands} )
# print bands $bands
integer band1 band2
if (( $#bands < 2 ))
then band1=1         band2=$bands[1]
else band1=$bands[1] band2=$bands[2]
fi
(( band1 == 0 )) && band1=1 # sed can't handle 0-base

# pattern='(print|word|tt|cc|con|tion|ment|able|ject|ould|ight|ment)'
pattern=${TTYP_PATTERN-.}
minwpm=${TTYP_MINWPM-50}
minacc=${TTYP_MINACC-95}
pensecs=${TTYP_PENSECS-1} # penalty seconds

# Set up logging
logdir=${XDG_DATA_HOME-~/.local/share}/ttypist
logwords=$logdir/ttypist-words.log
logsessions=$logdir/ttypist-sessions.log
if [[ ! -d $logdir ]]
then print "Creating new logging location: $logwords"
     mkdir -p $logdir
fi

autoload -U colors; colors

function shuffle { [[ ! -v TTYP_NOSHUF ]] && shuf <$1 || cat $1 ; }

# Print banner
integer nsessions=$(( $(sed -n '$=' $logsessions) + 1 ))
print  "$fg[blue]╭────────────────────────────────────╮"
printf          "│    TTYpist Typing Session #%-5s   │\n" $nsessions # include session number etc
print           "╰────────────────────────────────────╯$reset_color"
print "POOLBAND: $band1-$band2 | NWORDS: $nwords | MINWPM: $minwpm | DICT: $dict:t | PATTERN: $pattern"

# Select words randomly
if   [[ -n $1 ]]
then ques=( $(shuffle $1) )
else # Safe to cut field 2+ on single-column file; just grabs first field!
     # print -- cut -f3 $dict  'sed -n' "${band1},${band2}p"
     pool=$(cut -f3 $dict | sed -n "${band1},${band2}p" | grep -E $pattern | grep -E -v "[_'&]" | grep -E '...+')
     ques=( $( shuffle <(print $pool) | head -n $nwords) )
fi
queschars=$ques

# Show test words wrapped at 80 chars
function print_test {
     print
     fold -w80 -s <<<$1 | while read -r ln; do print "  $bold_color$ln"; done
     print -n $reset_color
}
print_test "$ques"

# Start typing test
print '\nStart typing to begin test, <enter> to end.\n'
read -sk1 'char1?> '
print -n "$char1"
integer t0; t0=$(date '+%s') # separating to appease shellcheck
read && ans=( $char1$=REPLY )

# Collect results
typos=(  $( comm -13 <(sort <(print -l $ques)) <(sort <(print -l $ans))) )
misses=( $( comm -23 <(sort <(print -l $ques)) <(sort <(print -l $ans))) )
hits=(   $( comm -12 <(sort <(print -l $ques)) <(sort <(print -l $ans))) )
integer maxlen=0; for m in $typos; do (( $#m > maxlen )) && maxlen=$#m; done

# Show missed words in vertial list (in red)
print
diff -y -1  <(print -l $ans) <(print -l $ques) | grep '|' |
     while read -r line
     do parts=( $(sed -r 's/[ \t]+\|[ \t]+/ /' <<<$line) )
        printf "$fg[red]%-${maxlen}s$reset_color -> %s\n" $parts[1] $parts[2]
     done

# Show missed words as short red list (disabled since vertical list probably sufficient)
penalty=$(( $#misses * $pensecs. ))
if   [[ -n $misses ]]
then : print "\nMissed words: $fg[red]$misses$reset_color"
else print "$fg_bold[green]PERFECT! No missed words! (go faster)$reset_color"
fi

# Log missed words for future stats
# TODO when becomes possible, log time taken
for m in $misses; do print "$m\t$t0\tfail" >>$logwords; done
for h in $hits;   do print "$h\t$t0\tpass" >>$logwords; done

# Finish timings
t1=$(date '+%s')
testtime=$(( t1 - t0 ))
pentime=$(( testtime + penalty ))
print "\nTest of $#ques words took $testtime seconds."

# Print summary stats
rawwpm=$(( $#queschars / 5. / testtime * 60 ))
penwpm=$(( $#queschars / 5. / pentime  * 60 ))
wpmcolor=red; (( minwpm < penwpm  )) && wpmcolor=green
integer ncorrect=$( comm -12 <(sort <(print -l $ques)) <(sort <(print -l $ans)) | wc -l )
accuracy=$(( $ncorrect. / $#ques * 100 ))
acccolor=red; (( minacc <= accuracy )) && acccolor=green
printf "WPM: $fg_bold[$wpmcolor]%.1f$reset_color (raw: %.1f)\n" $penwpm $rawwpm
printf "Acc: $fg_bold[$acccolor]%.0f%%$reset_color ($ncorrect/$#ques)\n" $accuracy

# Get previous high score
integer prevhi=$(grep "	$nwords$" $logsessions |cut -f2 | sort -n | tail -1)
if   (( prevhi < penwpm ))
then print "$fg_bold[blue]Congrats! New high score!!$reset_color"
fi

# Log session details to tracking files
printf "%d\t%.1f\t%.1f\t%d\n" $t0 $penwpm $accuracy $nwords >> $logsessions

# Do missed words practice round
if   [[ -n $misses ]]
then # shellcheck disable=1009
     for w in $misses
     do   repeats+="$w $w $w $w "
          if [[ -z $TTYP_CHUNKS ]] || (( $#w < 4 )); then continue; fi
          # Word chunks
          # i1=$(( RANDOM % ( $#x + 1 - 4 ) + 1 )); i2=$(( i1 + 3 )); print $i1 $i2 $x[$i1,$i2]
          # shellcheck disable=1073,2034
          for  i in {1..8}
          do   i1=$(( RANDOM % ( $#w + 1 - 4 ) + 1 )); i2=$(( i1 + 3 ))
               chunk="$w[$i1,$i2] "; repeats+=$chunk; ques+=$chunk
          done
     done
     # $foo $#foo foo+ foo.
     print "\nType these missed words (untimed free-form, as many times as you like):"
     freeform=$( print $(print -l $=repeats | shuf) )
     print_test "$freeform"
     print
     read  'retake?> ' # this is storing the response in the "retake" var
     pat=$(print -l $retake | sort -u | sed -r 's/ +/|/g')
     # print -- pat: "$pat"
     goods=( $(grep -E "($pat)" <<<$ques) )
     sobads=( $(comm -13 <(print -l $goods | sort -u) <(print -l $=retake | sort -u)) )
     if   [[ -n $sobads ]]
     then print "\nTypos: $fg[red]${(j: :)sobads}$reset_color"
     else print "\n$fg[green]NICE!$reset_color"
     fi
fi

# Exit with WPM as fail status if speed too slow
(( penwpm < minwpm )) && exit "$(printf '%d' $penwpm)" || exit 0
